{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","dependencies":[{"name":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/src/Session.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/jerry/DemoRuben/package.json","includedInParent":true,"mtime":1620201948000},{"name":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1625694109603},{"name":"events","loc":{"line":4,"column":25},"parent":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/home/jerry/DemoRuben/node_modules/events/events.js"},{"name":"uuid","loc":{"line":5,"column":23},"parent":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/home/jerry/DemoRuben/node_modules/uuid/dist/esm-browser/index.js"},{"name":"./dependencies","loc":{"line":6,"column":31},"parent":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/dependencies.js"},{"name":"./constant","loc":{"line":7,"column":27},"parent":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/home/jerry/DemoRuben/node_modules/@inrupt/solid-client-authn-browser/dist/constant.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Session = void 0;\nconst events_1 = require(\"events\");\nconst uuid_1 = require(\"uuid\");\nconst dependencies_1 = require(\"./dependencies\");\nconst constant_1 = require(\"./constant\");\nasync function silentlyAuthenticate(sessionId, clientAuthn) {\n    var _a;\n    const storedSessionInfo = await clientAuthn.validateCurrentSession();\n    if (storedSessionInfo !== null) {\n        window.localStorage.setItem(constant_1.KEY_CURRENT_URL, window.location.href);\n        await clientAuthn.login({\n            sessionId,\n            prompt: \"none\",\n            oidcIssuer: storedSessionInfo.issuer,\n            redirectUrl: storedSessionInfo.redirectUrl,\n            clientId: storedSessionInfo.clientAppId,\n            clientSecret: storedSessionInfo.clientAppSecret,\n            tokenType: (_a = storedSessionInfo.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\",\n        });\n    }\n}\nclass Session extends events_1.EventEmitter {\n    constructor(sessionOptions = {}, sessionId) {\n        super();\n        this.tokenRequestInProgress = false;\n        this.tmpFetchWithCookies = false;\n        this.login = async (options) => {\n            var _a;\n            await this.clientAuthentication.login({\n                sessionId: this.info.sessionId,\n                ...options,\n                tokenType: (_a = options.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\",\n            });\n        };\n        this.fetch = async (url, init) => {\n            return this.clientAuthentication.fetch(url, {\n                ...init,\n                credentials: this.tmpFetchWithCookies\n                    ?\n                        \"include\"\n                    :\n                        init === null || init === void 0 ? void 0 : init.credentials,\n            });\n        };\n        this.logout = async () => {\n            await this.clientAuthentication.logout(this.info.sessionId);\n            this.info.isLoggedIn = false;\n            this.tmpFetchWithCookies = false;\n            this.emit(\"logout\");\n        };\n        this.handleIncomingRedirect = async (inputOptions = {}) => {\n            var _a;\n            if (this.info.isLoggedIn) {\n                return this.info;\n            }\n            if (this.tokenRequestInProgress) {\n                return undefined;\n            }\n            const options = typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n            const url = (_a = options.url) !== null && _a !== void 0 ? _a : window.location.href;\n            if (options.useEssSession !== true ||\n                options.restorePreviousSession === true) {\n                window.localStorage.setItem(\"tmp-resource-server-session-enabled\", \"false\");\n            }\n            else {\n                window.localStorage.setItem(\"tmp-resource-server-session-enabled\", \"true\");\n            }\n            const storedSessionCookieReference = window.localStorage.getItem(\"tmp-resource-server-session-info\");\n            if (typeof storedSessionCookieReference === \"string\" &&\n                options.restorePreviousSession !== true &&\n                options.useEssSession === true) {\n                function isValidSessionCookieReference(reference) {\n                    var _a;\n                    const resourceServers = Object.keys((_a = reference.sessions) !== null && _a !== void 0 ? _a : {});\n                    return (typeof reference.webId === \"string\" &&\n                        resourceServers.length > 0 &&\n                        typeof reference.sessions[resourceServers[0]].expiration === \"number\");\n                }\n                const reference = JSON.parse(storedSessionCookieReference);\n                if (isValidSessionCookieReference(reference)) {\n                    const resourceServers = Object.keys(reference.sessions);\n                    const webIdOrigin = new URL(reference.webId).hostname;\n                    const ownResourceServer = resourceServers.find((resourceServer) => {\n                        return new URL(resourceServer).hostname === webIdOrigin;\n                    });\n                    const relevantServer = ownResourceServer !== null && ownResourceServer !== void 0 ? ownResourceServer : resourceServers[0];\n                    if (reference.sessions[relevantServer].expiration - Date.now() >\n                        5 * 60 * 1000) {\n                        this.info.isLoggedIn = true;\n                        this.info.webId = reference.webId;\n                        this.tmpFetchWithCookies = true;\n                        return this.info;\n                    }\n                }\n            }\n            this.tokenRequestInProgress = true;\n            const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url);\n            if (sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.isLoggedIn) {\n                this.info.isLoggedIn = sessionInfo.isLoggedIn;\n                this.info.webId = sessionInfo.webId;\n                this.info.sessionId = sessionInfo.sessionId;\n                const currentUrl = window.localStorage.getItem(constant_1.KEY_CURRENT_URL);\n                if (currentUrl === null) {\n                    this.emit(\"login\");\n                }\n                else {\n                    window.localStorage.removeItem(constant_1.KEY_CURRENT_URL);\n                    this.emit(\"sessionRestore\", currentUrl);\n                }\n                if (typeof sessionInfo.expirationDate === \"number\") {\n                    setTimeout(async () => {\n                        await this.logout();\n                    }, sessionInfo.expirationDate - Date.now());\n                }\n            }\n            else if (options.restorePreviousSession === true) {\n                const storedSessionId = window.localStorage.getItem(constant_1.KEY_CURRENT_SESSION);\n                if (storedSessionId !== null) {\n                    await silentlyAuthenticate(storedSessionId, this.clientAuthentication);\n                    return new Promise(() => { });\n                }\n            }\n            this.tokenRequestInProgress = false;\n            return sessionInfo;\n        };\n        if (sessionOptions.clientAuthentication) {\n            this.clientAuthentication = sessionOptions.clientAuthentication;\n        }\n        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({\n                secureStorage: sessionOptions.secureStorage,\n                insecureStorage: sessionOptions.insecureStorage,\n            });\n        }\n        else {\n            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({});\n        }\n        if (sessionOptions.sessionInfo) {\n            this.info = {\n                sessionId: sessionOptions.sessionInfo.sessionId,\n                isLoggedIn: false,\n                webId: sessionOptions.sessionInfo.webId,\n            };\n        }\n        else {\n            this.info = {\n                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : uuid_1.v4(),\n                isLoggedIn: false,\n            };\n        }\n    }\n    onLogin(callback) {\n        this.on(\"login\", callback);\n    }\n    onLogout(callback) {\n        this.on(\"logout\", callback);\n    }\n    onSessionRestore(callback) {\n        this.on(\"sessionRestore\", callback);\n    }\n}\nexports.Session = Session;\n"},"sourceMaps":{"js":{"version":3,"file":"Session.js","sourceRoot":"","sources":["../src/Session.ts"],"names":[],"mappings":";;;AAwBA,mCAAsC;AAOtC,+BAA0B;AAE1B,iDAAyE;AACzE,yCAAkE;AA4DlE,KAAK,UAAU,oBAAoB,CACjC,SAAiB,EACjB,WAAiC;;IAMjC,MAAM,iBAAiB,GAAG,MAAM,WAAW,CAAC,sBAAsB,EAAE,CAAC;IACrE,IAAI,iBAAiB,KAAK,IAAI,EAAE;QAK9B,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,0BAAe,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnE,MAAM,WAAW,CAAC,KAAK,CAAC;YACtB,SAAS;YACT,MAAM,EAAE,MAAM;YACd,UAAU,EAAE,iBAAiB,CAAC,MAAM;YACpC,WAAW,EAAE,iBAAiB,CAAC,WAAW;YAC1C,QAAQ,EAAE,iBAAiB,CAAC,WAAW;YACvC,YAAY,EAAE,iBAAiB,CAAC,eAAe;YAC/C,SAAS,EAAE,MAAA,iBAAiB,CAAC,SAAS,mCAAI,MAAM;SACjD,CAAC,CAAC;KACJ;AACH,CAAC;AAKD,MAAa,OAAQ,SAAQ,qBAAY;IA4BvC,YACE,iBAA2C,EAAE,EAC7C,SAAkB;QAElB,KAAK,EAAE,CAAC;QAxBF,2BAAsB,GAAG,KAAK,CAAC;QAG/B,wBAAmB,GAAG,KAAK,CAAC;QAwDpC,UAAK,GAAG,KAAK,EAAE,OAA2B,EAAiB,EAAE;;YAC3D,MAAM,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC;gBACpC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,SAAS;gBAC9B,GAAG,OAAO;gBAEV,SAAS,EAAE,MAAA,OAAO,CAAC,SAAS,mCAAI,MAAM;aACvC,CAAC,CAAC;QACL,CAAC,CAAC;QAQF,UAAK,GAAG,KAAK,EAAE,GAAgB,EAAE,IAAkB,EAAqB,EAAE;YACxE,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,GAAG,EAAE;gBAC1C,GAAG,IAAI;gBACP,WAAW,EAAE,IAAI,CAAC,mBAAmB;oBACnC,CAAC;wBACC,SAAS;oBACX,CAAC;wBACC,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,WAAW;aACtB,CAAC,CAAC;QACL,CAAC,CAAC;QAKF,WAAM,GAAG,KAAK,IAAmB,EAAE;YACjC,MAAM,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5D,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YAC7B,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;YACjC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC;QAQF,2BAAsB,GAAG,KAAK,EAC5B,eAAwD,EAAE,EACvB,EAAE;;YACrC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBACxB,OAAO,IAAI,CAAC,IAAI,CAAC;aAClB;YAED,IAAI,IAAI,CAAC,sBAAsB,EAAE;gBAC/B,OAAO,SAAS,CAAC;aAClB;YACD,MAAM,OAAO,GACX,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC;YAC1E,MAAM,GAAG,GAAG,MAAA,OAAO,CAAC,GAAG,mCAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;YAUhD,IACE,OAAO,CAAC,aAAa,KAAK,IAAI;gBAC9B,OAAO,CAAC,sBAAsB,KAAK,IAAI,EACvC;gBACA,MAAM,CAAC,YAAY,CAAC,OAAO,CACzB,qCAAqC,EACrC,OAAO,CACR,CAAC;aACH;iBAAM;gBACL,MAAM,CAAC,YAAY,CAAC,OAAO,CACzB,qCAAqC,EACrC,MAAM,CACP,CAAC;aACH;YACD,MAAM,4BAA4B,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAC9D,kCAAkC,CACnC,CAAC;YACF,IACE,OAAO,4BAA4B,KAAK,QAAQ;gBAChD,OAAO,CAAC,sBAAsB,KAAK,IAAI;gBACvC,OAAO,CAAC,aAAa,KAAK,IAAI,EAC9B;gBAKA,SAAS,6BAA6B,CACpC,SAAkC;;oBAElC,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CACjC,MAAC,SAAmC,CAAC,QAAQ,mCAAI,EAAE,CACpD,CAAC;oBACF,OAAO,CACL,OAAQ,SAAmC,CAAC,KAAK,KAAK,QAAQ;wBAC9D,eAAe,CAAC,MAAM,GAAG,CAAC;wBAC1B,OAAQ,SAAmC,CAAC,QAAQ,CAClD,eAAe,CAAC,CAAC,CAAC,CACnB,CAAC,UAAU,KAAK,QAAQ,CAC1B,CAAC;gBACJ,CAAC;gBACD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;gBAC3D,IAAI,6BAA6B,CAAC,SAAS,CAAC,EAAE;oBAC5C,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;oBACxD,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC;oBACtD,MAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,cAAc,EAAE,EAAE;wBAChE,OAAO,IAAI,GAAG,CAAC,cAAc,CAAC,CAAC,QAAQ,KAAK,WAAW,CAAC;oBAC1D,CAAC,CAAC,CAAC;oBAIH,MAAM,cAAc,GAAG,iBAAiB,aAAjB,iBAAiB,cAAjB,iBAAiB,GAAI,eAAe,CAAC,CAAC,CAAC,CAAC;oBAI/D,IACE,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE;wBAC1D,CAAC,GAAG,EAAE,GAAG,IAAI,EACb;wBACA,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;wBAC5B,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;wBAClC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;wBAChC,OAAO,IAAI,CAAC,IAAI,CAAC;qBAClB;iBACF;aACF;YAGD,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;YACnC,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,sBAAsB,CACxE,GAAG,CACJ,CAAC;YACF,IAAI,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,UAAU,EAAE;gBAC3B,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,UAAU,CAAC;gBAC9C,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;gBACpC,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,SAAS,CAAC;gBAC5C,MAAM,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,0BAAe,CAAC,CAAC;gBAChE,IAAI,UAAU,KAAK,IAAI,EAAE;oBAGvB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACpB;qBAAM;oBAIL,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,0BAAe,CAAC,CAAC;oBAChD,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC;iBACzC;gBAED,IAAI,OAAO,WAAW,CAAC,cAAc,KAAK,QAAQ,EAAE;oBAClD,UAAU,CAAC,KAAK,IAAI,EAAE;wBACpB,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;oBACtB,CAAC,EAAE,WAAW,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;iBAC7C;aACF;iBAAM,IAAI,OAAO,CAAC,sBAAsB,KAAK,IAAI,EAAE;gBAMlD,MAAM,eAAe,GAAG,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,8BAAmB,CAAC,CAAC;gBAGzE,IAAI,eAAe,KAAK,IAAI,EAAE;oBAC5B,MAAM,oBAAoB,CAAC,eAAe,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;oBAKvE,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;iBAC9B;aACF;YACD,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC;YACpC,OAAO,WAAW,CAAC;QACrB,CAAC,CAAC;QAlNA,IAAI,cAAc,CAAC,oBAAoB,EAAE;YACvC,IAAI,CAAC,oBAAoB,GAAG,cAAc,CAAC,oBAAoB,CAAC;SACjE;aAAM,IAAI,cAAc,CAAC,aAAa,IAAI,cAAc,CAAC,eAAe,EAAE;YACzE,IAAI,CAAC,oBAAoB,GAAG,sDAAuC,CAAC;gBAClE,aAAa,EAAE,cAAc,CAAC,aAAa;gBAC3C,eAAe,EAAE,cAAc,CAAC,eAAe;aAChD,CAAC,CAAC;SACJ;aAAM;YACL,IAAI,CAAC,oBAAoB,GAAG,sDAAuC,CAAC,EAAE,CAAC,CAAC;SACzE;QAED,IAAI,cAAc,CAAC,WAAW,EAAE;YAC9B,IAAI,CAAC,IAAI,GAAG;gBACV,SAAS,EAAE,cAAc,CAAC,WAAW,CAAC,SAAS;gBAC/C,UAAU,EAAE,KAAK;gBACjB,KAAK,EAAE,cAAc,CAAC,WAAW,CAAC,KAAK;aACxC,CAAC;SACH;aAAM;YACL,IAAI,CAAC,IAAI,GAAG;gBACV,SAAS,EAAE,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,SAAE,EAAE;gBAC5B,UAAU,EAAE,KAAK;aAClB,CAAC;SACH;IACH,CAAC;IAoMD,OAAO,CAAC,QAAuB;QAC7B,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC7B,CAAC;IAOD,QAAQ,CAAC,QAAuB;QAC9B,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;IAC9B,CAAC;IAUD,gBAAgB,CAAC,QAAyC;QACxD,IAAI,CAAC,EAAE,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;IACtC,CAAC;CACF;AArRD,0BAqRC","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n */\nimport { EventEmitter } from \"events\";\nimport {\n  ILoginInputOptions,\n  ISessionInfo,\n  IStorage,\n  ResourceServerSession,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\nimport { KEY_CURRENT_SESSION, KEY_CURRENT_URL } from \"./constant\";\n\nexport interface ISessionOptions {\n  /**\n   * A private storage, unreachable to other scripts on the page. Typically in-memory.\n   */\n  secureStorage: IStorage;\n  /**\n   * A storage where non-sensitive information may be stored, potentially longer-lived than the secure storage.\n   */\n  insecureStorage: IStorage;\n  /**\n   * Details about the current session\n   */\n  sessionInfo: ISessionInfo;\n  /**\n   * An instance of the library core. Typically obtained using `getClientAuthenticationWithDependencies`.\n   */\n  clientAuthentication: ClientAuthentication;\n}\n\nexport interface IHandleIncomingRedirectOptions {\n  /**\n   * If the user has signed in before, setting this to `true` will automatically\n   * redirect them to their Solid Identity Provider, which will then attempt to\n   * re-activate the session and send the user back to your app without\n   * requiring user interaction.\n   * If your app's access has not expired yet and re-activation completed\n   * successfully, a `sessionRestore` event will be fired with the URL the user\n   * was at before they were redirected to their Solid Identity Provider.\n   * {@see onSessionRestore}\n   */\n  restorePreviousSession?: boolean;\n\n  /**\n   * Inrupt's Enterprise Solid Server can set a cookie to allow the browser to\n   * access private resources on a Pod. In order to mitigate the logout-on-refresh\n   * issue on the short term, the server also implemented a session endpoint\n   * enabling the client app to know whether the cookie is set. When a user\n   * logs in to a server that has that capability enabled, applications that set\n   * this option to `true` will be able to make use of it.\n   *\n   * If your app supports the newest session restore approach, and `restorePreviousSession`\n   * is set to true, this option is automatically set to false, but your app will\n   * not be logged out when reloaded.\n   *\n   * `useEssSession` defaults to false and will be removed in the future; to\n   * preserve sessions across page reloads, use of `restorePreviousSession` is\n   * recommended.\n   */\n  useEssSession?: boolean;\n  /**\n   * The URL of the page handling the redirect, including the query\n   * parameters — these contain the information to process the login.\n   * Note: as a convenience, if no URL value is specified here, we default to\n   * using the browser's current location.\n   */\n  url?: string;\n}\n\nasync function silentlyAuthenticate(\n  sessionId: string,\n  clientAuthn: ClientAuthentication\n) {\n  // Check if we have an ID Token in storage - if we do then we may be\n  // currently logged in, and the user has refreshed their browser page. The ID\n  // token is validated, and on success the current session information are returned,\n  // now that we know they have not been tampered with.\n  const storedSessionInfo = await clientAuthn.validateCurrentSession();\n  if (storedSessionInfo !== null) {\n    // It can be really useful to save the user's current browser location,\n    // so that we can restore it after completing the silent authentication\n    // on incoming redirect. This way, the user is eventually redirected back\n    // to the page they were on and not to the app's redirect page.\n    window.localStorage.setItem(KEY_CURRENT_URL, window.location.href);\n    await clientAuthn.login({\n      sessionId,\n      prompt: \"none\",\n      oidcIssuer: storedSessionInfo.issuer,\n      redirectUrl: storedSessionInfo.redirectUrl,\n      clientId: storedSessionInfo.clientAppId,\n      clientSecret: storedSessionInfo.clientAppSecret,\n      tokenType: storedSessionInfo.tokenType ?? \"DPoP\",\n    });\n  }\n}\n\n/**\n * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.\n */\nexport class Session extends EventEmitter {\n  /**\n   * Information regarding the current session.\n   */\n  public readonly info: ISessionInfo;\n\n  private clientAuthentication: ClientAuthentication;\n\n  private tokenRequestInProgress = false;\n\n  // Remove this when removing the `useEssSession` workaround:\n  private tmpFetchWithCookies = false;\n\n  /**\n   * Session object constructor. Typically called as follows:\n   *\n   * ```typescript\n   * const session = new Session();\n   * ```\n   *\n   * See also [getDefaultSession](https://docs.inrupt.com/developer-tools/api/javascript/solid-client-authn-browser/functions.html#getdefaultsession).\n   *\n   * @param sessionOptions The options enabling the correct instantiation of\n   * the session. Either both storages or clientAuthentication are required. For\n   * more information, see {@link ISessionOptions}.\n   * @param sessionId A string uniquely identifying the session.\n   *\n   */\n  constructor(\n    sessionOptions: Partial<ISessionOptions> = {},\n    sessionId?: string\n  ) {\n    super();\n\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage,\n      });\n    } else {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({});\n    }\n\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId,\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId ?? v4(),\n        isLoggedIn: false,\n      };\n    }\n  }\n\n  /**\n   * Triggers the login process. Note that this method will redirect the user away from your app.\n   *\n   * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.\n   * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.\n   */\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (options: ILoginInputOptions): Promise<void> => {\n    await this.clientAuthentication.login({\n      sessionId: this.info.sessionId,\n      ...options,\n      // Defaults the token type to DPoP\n      tokenType: options.tokenType ?? \"DPoP\",\n    });\n  };\n\n  /**\n   * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n   *\n   * @param url The URL from which data should be fetched.\n   * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).\n   */\n  fetch = async (url: RequestInfo, init?: RequestInit): Promise<Response> => {\n    return this.clientAuthentication.fetch(url, {\n      ...init,\n      credentials: this.tmpFetchWithCookies\n        ? /* istanbul ignore next Simulating a cookie-enabled session in tests is too much work for a temporary, disabled-by-default workaround: */\n          \"include\"\n        : /* istanbul ignore next Simulating a cookie-enabled session in tests is too much work for a temporary, disabled-by-default workaround: */\n          init?.credentials,\n    });\n  };\n\n  /**\n   * Logs the user out of the application. This does not log the user out of their Solid identity provider, and should not redirect the user away.\n   */\n  logout = async (): Promise<void> => {\n    await this.clientAuthentication.logout(this.info.sessionId);\n    this.info.isLoggedIn = false;\n    this.tmpFetchWithCookies = false;\n    this.emit(\"logout\");\n  };\n\n  /**\n   * Completes the login process by processing the information provided by the\n   * Solid identity provider through redirect.\n   *\n   * @param options See {@see IHandleIncomingRedirectOptions}.\n   */\n  handleIncomingRedirect = async (\n    inputOptions: string | IHandleIncomingRedirectOptions = {}\n  ): Promise<ISessionInfo | undefined> => {\n    if (this.info.isLoggedIn) {\n      return this.info;\n    }\n\n    if (this.tokenRequestInProgress) {\n      return undefined;\n    }\n    const options =\n      typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n    const url = options.url ?? window.location.href;\n\n    // Unfortunately, regular sessions are lost when the user refreshes the page or opens a new tab.\n    // While we're figuring out the API for a longer-term solution, as a temporary workaround some\n    // *resource* servers set a cookie that keeps the user logged in after authenticated requests,\n    // and expose the fact that they set it on a special endpoint.\n    // After login, we store that fact in LocalStorage. This means that we can now look for that\n    // data, and if present, indicate that the user is already logged in.\n    // Note that there are a lot of edge cases that won't work well with this approach, so it willl\n    // be removed in due time, and is disabled by default.\n    if (\n      options.useEssSession !== true ||\n      options.restorePreviousSession === true\n    ) {\n      window.localStorage.setItem(\n        \"tmp-resource-server-session-enabled\",\n        \"false\"\n      );\n    } else {\n      window.localStorage.setItem(\n        \"tmp-resource-server-session-enabled\",\n        \"true\"\n      );\n    }\n    const storedSessionCookieReference = window.localStorage.getItem(\n      \"tmp-resource-server-session-info\"\n    );\n    if (\n      typeof storedSessionCookieReference === \"string\" &&\n      options.restorePreviousSession !== true &&\n      options.useEssSession === true\n    ) {\n      // TOOD: Re-use the type used when writing this data:\n      // https://github.com/inrupt/solid-client-authn-js/pull/920/files#diff-659ac87dfd3711f4cfcea3c7bf6970980f4740fd59df45f04c7977bffaa23e98R118\n      // To keep temporary code together\n      // eslint-disable-next-line no-inner-declarations\n      function isValidSessionCookieReference(\n        reference: Record<string, unknown>\n      ): reference is ResourceServerSession {\n        const resourceServers = Object.keys(\n          (reference as ResourceServerSession).sessions ?? {}\n        );\n        return (\n          typeof (reference as ResourceServerSession).webId === \"string\" &&\n          resourceServers.length > 0 &&\n          typeof (reference as ResourceServerSession).sessions[\n            resourceServers[0]\n          ].expiration === \"number\"\n        );\n      }\n      const reference = JSON.parse(storedSessionCookieReference);\n      if (isValidSessionCookieReference(reference)) {\n        const resourceServers = Object.keys(reference.sessions);\n        const webIdOrigin = new URL(reference.webId).hostname;\n        const ownResourceServer = resourceServers.find((resourceServer) => {\n          return new URL(resourceServer).hostname === webIdOrigin;\n        });\n        // Usually the user's WebID is also a Resource server for them,\n        // so we pick the expiration time for that. If it doesn't exist,\n        // we just pick the first (and probably only) one:\n        const relevantServer = ownResourceServer ?? resourceServers[0];\n        // If the cookie is valid for fewer than five minutes,\n        // pretend it's not valid anymore already, to avoid small misalignments\n        // resulting in invalid states:\n        if (\n          reference.sessions[relevantServer].expiration - Date.now() >\n          5 * 60 * 1000\n        ) {\n          this.info.isLoggedIn = true;\n          this.info.webId = reference.webId;\n          this.tmpFetchWithCookies = true;\n          return this.info;\n        }\n      }\n    }\n    // end of temporary workaround.\n\n    this.tokenRequestInProgress = true;\n    const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(\n      url\n    );\n    if (sessionInfo?.isLoggedIn) {\n      this.info.isLoggedIn = sessionInfo.isLoggedIn;\n      this.info.webId = sessionInfo.webId;\n      this.info.sessionId = sessionInfo.sessionId;\n      const currentUrl = window.localStorage.getItem(KEY_CURRENT_URL);\n      if (currentUrl === null) {\n        // The login event can only be triggered **after** the user has been\n        // redirected from the IdP with access and ID tokens.\n        this.emit(\"login\");\n      } else {\n        // If an URL is stored in local storage, we are being logged in after a\n        // silent authentication, so remove our currently stored URL location\n        // to clean up our state now that we are completing the re-login process.\n        window.localStorage.removeItem(KEY_CURRENT_URL);\n        this.emit(\"sessionRestore\", currentUrl);\n      }\n\n      if (typeof sessionInfo.expirationDate === \"number\") {\n        setTimeout(async () => {\n          await this.logout();\n        }, sessionInfo.expirationDate - Date.now());\n      }\n    } else if (options.restorePreviousSession === true) {\n      // Silent authentication happens after a refresh, which means there are no\n      // OAuth params in the current location IRI. It can only succeed if a session\n      // was previously logged in, in which case its ID will be present with a known\n      // identifier in local storage.\n      // Check if we have a locally stored session ID...\n      const storedSessionId = window.localStorage.getItem(KEY_CURRENT_SESSION);\n      // ...if not, then there is no ID token, and so silent authentication cannot happen, but\n      // if we do have a stored session ID, attempt to re-authenticate now silently.\n      if (storedSessionId !== null) {\n        await silentlyAuthenticate(storedSessionId, this.clientAuthentication);\n        // At this point, we know that the main window will imminently be redirected.\n        // However, this redirect is asynchronous and there is no way to halt execution\n        // until it happens precisely. That's why the current Promise simply does not\n        // resolve.\n        return new Promise(() => {});\n      }\n    }\n    this.tokenRequestInProgress = false;\n    return sessionInfo;\n  };\n\n  /**\n   * Register a callback function to be called when a user completes login.\n   *\n   * The callback is called when {@link handleIncomingRedirect} completes successfully.\n   *\n   * @param callback The function called when a user completes login.\n   */\n  onLogin(callback: () => unknown): void {\n    this.on(\"login\", callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when a user completes logout.\n   */\n  onLogout(callback: () => unknown): void {\n    this.on(\"logout\", callback);\n  }\n\n  /**\n   * Register a callback function to be called when a session is restored.\n   *\n   * Note: the callback will be called with the saved value of the 'current URL'\n   * at the time the session was restored.\n   *\n   * @param callback The function called when a user's already logged-in session is restored, e.g., after a silent authentication is completed after a page refresh.\n   */\n  onSessionRestore(callback: (currentUrl: string) => unknown): void {\n    this.on(\"sessionRestore\", callback);\n  }\n}\n"]}},"error":null,"hash":"8858ff1de9d1931f6a26d8aef6b06690","cacheData":{"env":{}}}